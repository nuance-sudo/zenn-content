---
title: "Vertex AI Agent Engine Memory Bank 入門：メモリの生成・統合・取得の仕組みを整理する"
emoji: "🧠"
type: "tech"
topics: ["初心者", "agent", "memorybank", "google-cloud", "vertex-ai"]
published: false
---

## 1. はじめに

先日の「第4回 Agentic AI Hackathon with Google Cloud」に参加し、絵のコーチングエージェント「Art coachIng」を開発しました。その際、ユーザーの過去の評価や成長記録を保持するために Vertex AI Agent Engine の「Memory Bank」機能を利用しました。

Memory Bank はマネージドサービスとして非常に便利で、複雑なメモリ管理のロジックを意識せずに実装できたのですが、ハッカソン中は「とにかく動かすこと」を優先してしまい、裏側の仕組みを体系的に学習できていませんでした。

本記事では、自身の復習のために作成した学習用リポジトリをベースに、公式ドキュメントを参照しながら Memory Bank の基本的な仕組みと、実践的な生成・取得のワークフローを整理します。

## 2. Vertex AI Agent Engine Memory Bank とは？

Vertex AI Agent Engine Memory Bank は、ユーザーとエージェントの会話（セッション）に基づいて、**長期記憶を動的に生成・管理できるマネージドサービス**です。ステートレスなエージェントに特定のユーザーに紐づく記憶を持たせることで、セッションをまたいだパーソナライズされた体験を提供できます。

本記事で扱う「記憶の作成と取得」に関連する主な機能は以下の通りです。

### 記憶の自律的な抽出と統合

ソースデータから最も意味のある情報のみを抽出し、記憶として永続化します。さらに、新しく抽出された情報を既存のメモリと統合し、新しい情報が取り込まれるにつれてメモリを自動的に進化（作成・更新・削除）させます。

### トピックによるカスタマイズ可能な抽出

特定のトピックを指定することで、Memory Bank が「何を意味のある情報と見なすか」を柔軟に構成・カスタマイズできます。

### 非同期生成

メモリをバックグラウンドで生成します。これにより、エージェントはメモリ生成が完了するまで待つ必要がなくなります。

### スコープによるデータ分離

メモリの統合と取得は、特定の ID（ユーザーIDやシステムIDなど）のスコープに限定されます。これにより、マルチテナント環境や複数システムの記憶が混ざることを防ぎ、安全なメモリ管理を実現します。

### 類似性検索とフィルタリングによる取得

特定の ID にスコープ設定された類似性検索を使用して、現在の会話に最も関連するメモリを取得します。メタデータやシステムフィールドによるフィルタリングと組み合わせることも可能です。

### マルチモーダル入力の処理

テキストだけでなく、画像や音声などのマルチモーダル情報を処理し、テキスト形式の分析結果をメモリとして保存します。

## 3-1. メモリの生成と保存

エージェントに長期記憶を持たせる第一歩は、ユーザーとの会話履歴から有益な情報を抽出し、Memory Bank に保存することです。

### ① セッションとスコープ（Scope）による記憶の分離

Memory Bank では、会話履歴（セッション）をソースとして記憶を生成します。このとき、記憶の帰属先（誰の・どの文脈の記憶か）を定義するキーが「**スコープ（Scope）**」です。

スコープは単一の文字列ではなく、**最大5つの要素を持てる複合キー（辞書型）** として定義できるのが大きな特徴です。この複合キーを利用することで、記憶の細かい分離が可能になります。

例えば、単に `user_id` だけで紐づけるだけでなく、`system_id` などを組み合わせることで、同じユーザーでも「どの業務・システムの文脈か」を明確に分けて管理できます。

**ハンズオン実装（Step 1）をベースにしたスコープ定義の例：**

```python
session = sessions_client.create_session(
    parent=agent_engine_name,
    session={
        # 複合キーとして最大5つまで設定可能
        "user_id": "user_123",
        "system_id": "order_management"  # 例：発注システムの文脈を指定
    }
)
```

このように設定することで、「発注システム」と「在庫管理システム」など、複数のアプリケーション間で記憶が混ざるのを防ぐだけでなく、後から特定のコンテキストに絞って的確にメモリを引き出せるようになります。

**【コンソールでの確認】**

実際に生成されたメモリをコンソールで確認すると、スコープ（`system_id: order_management`, `user_id: user_123`）が正しく設定されていることがわかります。

![生成されたメモリの例：スコープや事実が構造化されて保存されている](/images/hello-memorybank/consolidation-before.png)

### ② 記憶対象を決める「トピック（Topics）」

会話履歴をすべて保存すると、挨拶などのノイズでデータベースが溢れてしまいます。Memory Bank には「**トピック（Topics）**」という概念があり、会話の中から「どの情報をピックアップして記憶に残すか」を自動で制御できます。

デフォルトでは以下の4つのトピックが有効になっており、LLM が文脈から自律的に判断して事実を抽出・要約します。

- **個人情報**：ユーザーの所属や役割など
- **ユーザーの好み**：よく使う設定や好みの条件
- **重要な詳細**：会話の結論や業務の決定事項
- **明示的な指示**：「〜を覚えておいて」という直接的な指定

**【ユースケース：発注システムの場合】**

このトピック機能により、システムとのやり取りは以下のように自動で仕分けられます。

> ユーザー：「お疲れ様です。今日は発注が多いですね」
> ➔ 単なる挨拶や雑談なので**記憶しない**

> ユーザー：「A4コピー用紙を発注して。業者はいつも通りA社でお願い」
> ➔ 今後の発注を効率化する情報として「**ユーザーの好み・重要な詳細**」に記憶する

> ユーザー：「来月からは納品先を2階のオフィスに変更することを覚えておいて」
> ➔ 「**明示的な指示**」として確実に記憶する

このように、開発者側で複雑な情報抽出プロンプトを書かなくても、エージェントが自動で不要なノイズを弾き、業務のパーソナライズに必要なコア情報だけを効率よく蓄積してくれます。

### ③ 生成されるメモリのデータ構造

`GenerateMemories` を実行して Memory Bank に記憶が保存されると、単なるテキストのログではなく、検索や管理に役立つ構造化されたデータ（Memory オブジェクト）として生成されます。

- **`fact`（記憶の内容）**：LLM が会話から抽出し、一人称視点で生成した事実のテキストです。
- **`scope`（スコープ）**：記憶が属する境界のキーです。
- **`metadata`（メタデータ）**：保存時に開発者が任意で付与したタグ情報です。
- **自動付与されるシステムフィールド**：Memory Bank の裏側で自動的に付与・更新される管理用のフィールドです。
  - `topics`：会話の内容から LLM が自動分類したトピック（`USER_PREFERENCES` など）。
  - `create_time` / `update_time`：記憶が最初に作成された日時と更新された日時。

後述する「記憶の取得（Retrieve）」では、ここで作られた `metadata` やシステムフィールドを使って、必要な記憶だけを正確にフィルタリングして引き出すことになります。

### ④ Generate と Create の違い

Memory Bank への記憶の保存方法には、大きく分けて `GenerateMemories` と `CreateMemory` の2つがあります。

- **`GenerateMemories`**：セッションの会話履歴を元に、LLM が自動で事実を抽出し、既存の記憶と「統合」を行ってくれます。基本はこちらを使用します。
- **`CreateMemory`**：抽出済みの事実を直接 Memory Bank に書き込みます。ただし、既存のメモリと統合されないため、同じスコープ内で記憶が重複するリスクがあり注意が必要です。

### ⑤ 統合（Consolidation）の仕組み

`GenerateMemories` の特徴は、単純な情報の追記ではなく、LLM による「統合（Consolidation）」が自動で行われる点です。

LLM エージェントに長期記憶を実装する際、自前でベクトルデータベースを構築すると「記憶の矛盾」という大きな壁にぶつかります。例えば、ユーザーの好みが変わったときに、単に追記していくだけでは「過去の古い記憶」と「最新の記憶」が混在し、エージェントが間違った情報を引き出してしまうリスクがあります。

Memory Bank の統合機能は、会話から新しく抽出された情報と、同じスコープ内にある既存の記憶を自動的に比較し、以下の3つのアクションから最適なものを判断して実行します。

- **作成（CREATED）**：既存の記憶に該当するものがない、全く新しい事実であれば新規のメモリとして追加します。
- **更新（UPDATED）**：既存の記憶とテーマが同じで、内容が変化している場合は、最新の情報に上書き（更新）します。
- **削除（DELETED）**：新しい情報が既存の記憶と完全に矛盾する場合や、ユーザーから明示的な削除指示があった場合、該当する古い記憶を削除します。

**【統合の具体例（発注システムの場合）】**

- **既存の記憶**：「A4用紙のデフォルト発注業者はA社」
- **今回の会話**：「来月からA4用紙の業者はC社に変更して」
- **Memory Bank の動作**：単に「C社」という新しい記憶を追加するのではなく、文脈を理解し、既存の「A社」の記憶を「C社」に更新（UPDATED）します。

**【コンソールでの確認】**

統合後のメモリをコンソールで確認すると、事実が「来月からA4用紙の業者はC社です。」に更新されていることがわかります。

![統合後：「来月からA4用紙の業者はC社です。」に更新された記憶](/images/hello-memorybank/consolidation-after.png)

> [!NOTE]
> 実際に試してみると、内部的には既存メモリの**削除（DELETED）→ 新規作成（CREATED）**という2ステップで処理されていました。

つまり `GenerateMemories` を活用すれば、開発者は「過去の類似メモリを探し出し、LLM に変更箇所を判定させ、古いレコードを削除・更新する」という非常に複雑な記憶のライフサイクル管理ロジックを一切書く必要がなくなります。

### ⑥ メタデータ（Metadata）の付与

Memory Bank では、記憶を生成・作成する際に、構造化された「メタデータ」を同時に付与することができます。

スコープ（Scope）が「誰の・どのシステムの記憶か」という大枠の箱（例：ユーザーAの、発注システムの記憶）を定義するものだとすれば、メタデータは個々の記憶に貼り付ける「付箋（タグ）」のような役割を果たします。

**【ユースケース：発注システムの場合】**

例えば、同じ発注システム内でも「部署」や「物品カテゴリ」ごとに異なるルールが存在するとします。会話から記憶を生成する際、LLM やシステム側で判断した属性をメタデータとして付与しておきます。

```python
agent_engine_client.generate_memories(
    name=agent_engine_name,
    # ...セッション情報の指定...
    metadata={
        "department": {"string_value": "sales"},       # 例: 「営業部」のタグ
        "item_category": {"string_value": "stationery"} # 例: 「文房具」のタグ
    }
)
```

**【実行結果の例】**

![メタデータ付きメモリ生成の実行結果](/images/hello-memorybank/metadata-generate.png)

*メタデータ（department, item_category）が付与された状態でメモリが生成されている*

このようにメタデータを設定しておけば、ユーザーが「営業部の備品を追加で頼みたい」とリクエストした際に、発注システム全体の記憶から探すのではなく、「営業部」かつ「文房具」のメタデータを持つ記憶だけをピンポイントで取得できます。

曖昧なベクトル検索だけでなく、メタデータによる確実な条件絞り込み（Exact Match）を併用できるのも大きな強みです。

### ⑦ メタデータの更新戦略（metadata_merge_strategy）

メタデータは検索時に役立つだけでなく、`GenerateMemories` による「統合（Consolidation）」の挙動にも大きな影響を与えます。

統合時にメタデータをどう扱うかを決める `metadata_merge_strategy` という設定があり、要件に応じて以下の3つから選択します。

- **`MERGE`（デフォルト）**：新旧のメタデータを結合し、既存のキーは新しい値で上書きします。
- **`OVERWRITE`**：古いメタデータを新しいもので完全に置き換えます。
- **`REQUIRE_EXACT_MATCH`**：リクエストと完全に一致するメタデータを持つ記憶のみを統合（比較・更新）の対象に制限します。

今回のハッカソンで開発したエージェントでは、まさにこの「統合」の仕様で大きな失敗を経験しました。
このアプリには、ユーザーの過去のデッサンデータと比較して「成長スコア」を算出する機能があります。開発当初、記憶のスコープを「ユーザーID」とし、メタデータに「リンゴ」などのモチーフ名を持たせて、デフォルトの `MERGE` 戦略で記憶を生成していました。
すると、同じユーザーが同じモチーフ（リンゴ）の絵をアップロードするたびに、LLM が「同じ話題（リンゴのデッサン）の最新情報だ」と判断し、過去の評価メモリーを最新の評価で上書き（UPDATED）してしまったのです。
結果として過去の記憶が消え去り、「時系列でユーザーの成長を捉えて比較する」という本来の目的が達成できなくなってしまいました。
このような「過去の履歴を消さずに時系列で残していきたい」ケースでは、以下のような戦略的な設計が必要です。

- メタデータにセッションIDやタイムスタンプを含めた上で、`REQUIRE_EXACT_MATCH` を指定して意図しない上書きを防ぐ。
- LLM の自動統合に頼らず、都度 `CreateMemory` メソッドを使用して完全に独立した記録として追加していく。

> ただ便利だからと `GenerateMemories` を漫然と使うのではなく、「最新の状態を維持したい記憶」なのか「履歴として蓄積したい記憶」なのかを見極めて戦略を選択することが重要です。

### ⑧ マルチモーダル入力からのメモリ生成

Memory Bank は、テキストだけでなく画像・動画・音声といったマルチモーダル入力からもメモリを生成できます。

**注意点として、生成されるメモリ自体はテキスト形式です。** 画像や音声がそのまま保存されるわけではなく、マルチモーダルモデルが入力を解析し、その内容をテキストの事実として抽出・保存します。

例えば、ユーザーが「これは私の犬です」というテキストとともにゴールデンレトリバーの画像を送信した場合、Memory Bank は画像を解析し、「私の犬はゴールデンレトリバーです」というテキスト形式のメモリを生成します。

### ⑨ 非同期生成

ここまで紹介してきたメモリの生成処理は、バックグラウンドで非同期に実行できます。`wait_for_completion` を `False` に設定するだけで、エージェントはメモリ生成の完了を待たずに次の処理に進めるため、ユーザーへのレスポンスにレイテンシが加わる心配がありません。

```python
client.agent_engines.memories.generate(
    ...,
    config={
        "wait_for_completion": False
    }
)
```

## 3-2. メモリの取得（RetrieveMemories）

メモリを保存できたら、次はその記憶を会話の文脈に合わせて適切に引き出すプロセスが必要です。ここでは、Memory Bank が提供する取得メソッドとフィルタリング機能を整理します。

### ① 3つの取得メソッドの使い分け

Memory Bankから記憶を取得する際、APIには大きく分けて3つのメソッドが用意されています。

| メソッド | スコープ指定 | 主な用途 | 動作・戻り値 |
| --- | --- | --- | --- |
| **Retrieve** | **必要** (完全一致) | エージェントのプロンプト構築、類似検索 | 指定スコープ内の記憶リストを取得 |
| **Get** | 不要 | 特定の記憶のピンポイント参照 | リソース名指定で単一の `Memory` を取得 |
| **List** | 不要 | 記憶の全体把握 | Agent Engine内の全記憶を一覧取得 |

**`Get` と `List`（スコープ不要の取得）**
`Get` や `List` はスコープの指定が不要です。`list()` を使えば、Agent Engine内に保存されている全ユーザーのすべての記憶をページネーションで一覧取得できます。

取得した大量の記憶をすべてエージェントのプロンプトに組み込むと、トークンを大量に消費してしまうため注意が必要ですが、「今データベースにどんな記憶が保存されているか」を開発時に確認・デバッグするツールとして非常に重宝します。

```python
# Listの例：Agent Engine内の全メモリを一覧取得して確認
pager = client.agent_engines.memories.list(name=agent_engine_name)
for m in pager:
    # 記憶の内容、メタデータ、トピックなどを確認
    print(m.fact, m.metadata, m.topics) 

```

**`Retrieve`（スコープ内検索）**
本記事でメインに解説するのが `Retrieve` メソッドです。ユーザーとの会話の文脈に合わせて、必要なコンテキストだけを動的に引っ張ってくるために使用します 。ここからは、この `Retrieve` を使いこなすための重要ポイントを解説します。

### ② スコープの「完全一致」制約とメタデータによる検索設計

`Retrieve` を使う際、最初に意識すべき仕様が**「スコープ（Scope）の指定方法と検索範囲」**です。

記憶を取得する際、指定するスコープは**「完全一致（Exact Match）」**でなければならないという制約があります 。これを意識せずに記憶を保存していくと、後から横断的に検索する際に苦労することになります。

#### アンチパターン：スコープで細かく分けすぎる

たとえば、ある社員（ユーザー）が複数のプロジェクト（案件A、案件Bなど）を兼務しており、発注システム上でプロジェクトごとに文脈を分けたいと考え、スコープの複合キーに直接プロジェクトIDを含めて保存してしまったとします。

```python
# 記憶保存時：スコープでプロジェクトごとに細分化してしまう
session = sessions_client.create_session(
    session={
        "user_id": "user_123",
        "project_id": "project_A" # ❌ スコープにプロジェクトIDを含める
    }
)

```

この状態で保存すると、「今月、**自分が全プロジェクトで発注した**履歴を横断検索したい」と思ったときに壁にぶつかります。取得時のスコープに `{"user_id": "user_123"}` だけを指定しても取得対象にはなりません。横断検索をするには、すべての `project_id` に対して複数回検索（APIコール）を行う必要が生じてしまいます。

#### 回避策：メタデータに逃がして柔軟にフィルタリングする

「基本はプロジェクトごとに分けたいが、一括で横断検索したいケースもある」という場合は、細分化の条件をスコープではなく**「メタデータ (Metadata)」**に持たせるのがよさそうです。

* **スコープ**: 検索の絶対的な境界として広めに設定（例：`{"user_id": "user_123"}` のみ）
* **メタデータ**: 柔軟な絞り込み用タグとして付与（例：`{"project_id": "project_A"}`）

「スコープは越えられない壁、メタデータは柔軟なフィルタ」という役割分担を意識して設計することで、取得ロジックが格段に扱いやすくなります。

**【実行結果の例】**

![スコープの完全一致制約の確認結果](/images/hello-memorybank/retrieve-scope-constraint.png)

*存在しない `user_id` や、複合キーの部分一致では取得できないことが確認できる*

### ③ 2種類のフィルタリング

Memory Bank には、目的の記憶を絞り込むための2種類のフィルタが用意されています。これらは組み合わせて使用できます。

#### ① メタデータフィルタ（`filter_groups`）

自身で付与した構造化タグ（メタデータ）に対する絞り込みです。**DNF（論理和標準形：ANDのOR）形式で指定します 。
メタデータフィルタの最大の特徴は「完全一致のみ」**という点です。部分一致や大小比較はできないため、「プロジェクトA」や「優先度：高」といったカッチリとした属性での絞り込みに利用します。

```python
# 例：「プロジェクトA」かつ「優先度：高」の記憶に絞り込む
filter_groups=[{
    "filters": [
        {"key": "project_id", "value": {"string_value": "project_A"}},
        {"key": "priority", "value": {"string_value": "high"}}
    ]
}]

```

#### ② システムフィールドフィルタ（`filter`）

Memory Bankが自動で管理する属性（システムフィールド）に対する絞り込みです。`filter_groups` とは異なり、**EBNF構文**の文字列で指定するため、**正規表現による部分一致や、日時の範囲指定が可能**です 。

システムフィールドには主に以下の3つがあり、それぞれ専用の演算子が使えます 。

* **`fact`（記憶の内容）**
`=~` 演算子を使うことで、正規表現による部分一致検索が可能です。メタデータにタグ付けし忘れたキーワードでも、記憶のテキスト自体から抽出できます。
* 記述例：`fact=~".*PC.*"` （記憶のどこかに「PC」が含まれるもの）


* **`create_time` / `update_time`（作成・更新日時）**


`>=` や `<=` などの比較演算子を使い、期間を指定して絞り込めます。日時はISO 8601形式の文字列を二重引用符で囲む必要があります 。


* 記述例：`create_time>="2026-01-01T00:00:00Z"` （2026年1月1日以降に作成されたもの）


* **`topics`（トピック）**
`:`（HAS演算子）を使うことで、Memory Bankが自動付与したトピックで絞り込めます。
* 記述例：`topics.managed_memory_topic: USER_PREFERENCES`（マネージドトピックの絞り込み）

```python
# システムフィールドフィルタの使用例
response = client.agent_engines.memories.retrieve(
    name=agent_engine_name,
    scope={"user_id": "user_123"},
    config={
        # 「PC」を含む記憶のうち、2026年以降に作成されたものに絞り込み
        "filter": 'fact=~".*PC.*" AND create_time>="2026-01-01T00:00:00Z"'
    }
)
```

**【実行結果の例】**

システムフィールドフィルタによる絞り込み結果：

![システムフィールドフィルタの実行結果](/images/hello-memorybank/retrieve-system-filter.png)

*`fact` の部分一致や `create_time` の範囲指定で記憶を絞り込んでいる*

カスタムトピックによるフィルタリング結果：

![トピックフィルタの実行結果](/images/hello-memorybank/retrieve-topic-filter.png)

*カスタムトピック `ordering_rules` で絞り込んだ結果*

### ④ セマンティック検索（類似性検索）

Memory Bankでは、`similarity_search_params` を指定することでセマンティック検索（類似性検索）が可能です 。

デフォルトの取得処理では指定したスコープのメモリが全件返されますが、このパラメータを渡すことで、現在のクエリに最も関連する記憶のみに絞り込むことができます 。内部ではエンベディングベクトルが比較されており、単なるキーワード一致ではなく「意味的な類似度」に基づいて検索が行われます 。

たとえば、「趣味は何？」というクエリに対して、直接的なキーワードが含まれていなくても「休日はよく絵を描いています」といった意味的に近い記憶が抽出されます。

取得された記憶は、ユークリッド距離が最も短い（類似している）ものから順にソートされて返されます 。

```python
# セマンティック検索例
response = client.agent_engines.memories.retrieve(
    name=agent_engine_name,
    scope={"user_id": "user_123"},
    similarity_search_params={
        # 「趣味は何？」に意味的に近い記憶を上位3件取得
        "search_query": "趣味は何？",
        "top_k": 3
    }
)
```

**【実行結果の例】**

![セマンティック検索の実行結果](/images/hello-memorybank/retrieve-semantic-search.png)

*クエリごとに意味的に近い記憶が `distance`（ユークリッド距離）の昇順で返されている*